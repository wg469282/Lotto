
import java.util.*;

public class Blankiet {
    private List<Zaklad> zaklady;
    private List<Set<Integer>> strzaly;
    private int ileLosowan;
    private Kolektura k;

    public Blankiet(Kolektura kl, int ileL, List<Set<Integer>> strz) {

        this.k = kl;
        this.zaklady = new ArrayList<>();
        this.strzaly = strz;
        this.ileLosowan = ileL;
        for (Set<Integer> zbior : strz) {
            int[] typy = zbior.stream().mapToInt(Integer::intValue).toArray();
            if (typy.length != 6) {
                continue;
            }
            Arrays.sort(typy);
            zaklady.add(new Zaklad(typy));
        }
    }

    public void wydajBlankiet(Gracz g) {
        if (g.ilePieniedzy() >= this.ileLosowan * 300 * this.strzaly.size())
            this.k.wydajKupon(this.zaklady, this.ileLosowan, g);

    }

    @Override
    public String toString() {
        String s = "";
        for (int i = 0; i < 8; i++) {
            s += zaklady.get(i).toString();
        }
        s += "Liczba losowań:";
        for (int j = 1; j <= 10; j++) {
            s += "  [ ";
            if (j != this.zaklady.size() - 1)
                s += j + "";
            else
                s += "--";
            s += " ]";
        }
        return s;
    }
}


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class BlankietTest {
    private Centrala centrala;
    private Kolektura kolektura;

    @BeforeEach
    void setUp() {
        centrala = new Centrala(1, 1000000L);
        kolektura = centrala.getKolektury().get(0);
    }

    @Test
    void testTworzenieBlankietuZPoprawnymi6Liczbami() {
        Set<Integer> typ1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        List<Set<Integer>> typy = Arrays.asList(typ1);

        Blankiet blankiet = new Blankiet(kolektura, 1, typy);
        assertNotNull(blankiet);
    }

    @Test
    void testBlankietOdrzucaZakladyZNiepoprawnąLiczbąTypów() {
        Set<Integer> typ1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5)); // tylko 5 liczb
        Set<Integer> typ2 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7)); // 7 liczb
        List<Set<Integer>> typy = Arrays.asList(typ1, typ2);

        Blankiet blankiet = new Blankiet(kolektura, 1, typy);
        // Blankiet powinien zostać utworzony, ale niepoprawne zakłady będą pominięte
        assertNotNull(blankiet);
    }

    @Test
    void testBlankietZWielkąLiczbąLosowań() {
        Set<Integer> typ1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5, 6));
        List<Set<Integer>> typy = Arrays.asList(typ1);

        Blankiet blankiet = new Blankiet(kolektura, 10, typy);
        assertNotNull(blankiet);
    }

    @Test
    void testBlankietZPustąListąTypów() {
        List<Set<Integer>> typy = new ArrayList<>();

        Blankiet blankiet = new Blankiet(kolektura, 1, typy);
        assertNotNull(blankiet);
    }
}


import java.util.*;

public class BudzetPanstwa {
    private long budzet;// Zakladamy jako wlasciciele loterii mamy bardzo bliskie powiazanai z
                        // wladza(zapewne totalitarna)
    private long subwencje;
    private long podatki;

    public BudzetPanstwa() {
        this.budzet = 80920000000000L;// PKB Polski 2023, z załozenia wynika ze mamy dostep do calosci PKB
        this.subwencje = 0;
        this.podatki = 0;
    }

    public void dodajPieniadze(long l) {
        if (l < 0) {
            throw new IllegalArgumentException("Nie wolno wyciagac pieniedzy z kieszeni wszystkich Polek i Polakow");
        }
        this.podatki += l;
        this.budzet += l;
    }

    public void udzielSubwencji(long s) {
        if (budzet < s) {
            System.err.println("Jak do tego doszlo??");
            return;
        }
        subwencje += s;
        budzet -= s;

    }

    public void pobierzPodatek(long ile) {
        this.podatki += ile;
        this.budzet += ile;
    }

    public long getSubwencje() {
        return this.subwencje;
    }

    public long getPodatki() {
        return this.podatki;
    }

    public long getBudzet() {
        return this.budzet;
    }
    @Override
    public String toString() {
        String s = "";
        s += "Budzet Panstwa : "+this.budzet/100 +","+ this.budzet%100;
        s += "\nSubwencje : "+this.subwencje/100 +","+ this.subwencje%100;
        s += "\nPodatki : "+this.podatki/100 + ","+this.podatki%100;
        return s;
    }
}




import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;

public class BudzetPanstwaTest {
    private BudzetPanstwa budzetPanstwa;

    @BeforeEach
    void setUp() {
        budzetPanstwa = new BudzetPanstwa();
    }

    @Test
    void testDodawaniePodatkow() {
        long początkowePodatki = budzetPanstwa.getPodatki();
        long początkowyBudzet = budzetPanstwa.getBudzet();

        budzetPanstwa.dodajPieniadze(1000L);

        assertEquals(początkowePodatki + 1000L, budzetPanstwa.getPodatki());
        assertEquals(początkowyBudzet + 1000L, budzetPanstwa.getBudzet());
    }

    @Test
    void testUdzielanieSubwencji() {
        long początkoweSubwencje = budzetPanstwa.getSubwencje();
        long początkowyBudzet = budzetPanstwa.getBudzet();

        budzetPanstwa.udzielSubwencji(5000000L);

        assertEquals(początkoweSubwencje + 5000000L, budzetPanstwa.getSubwencje());
        assertEquals(początkowyBudzet - 5000000L, budzetPanstwa.getBudzet());
    }

    @Test
    void testDodawanieUjemnychPodatkow() {
        assertThrows(IllegalArgumentException.class, () -> {
            budzetPanstwa.dodajPieniadze(-1000L);
        });
    }

    @Test
    void testPobieraniePodatku() {
        long początkowePodatki = budzetPanstwa.getPodatki();
        long początkowyBudzet = budzetPanstwa.getBudzet();

        budzetPanstwa.pobierzPodatek(2000L);

        assertEquals(początkowePodatki + 2000L, budzetPanstwa.getPodatki());
        assertEquals(początkowyBudzet + 2000L, budzetPanstwa.getBudzet());
    }
}


import java.util.*;

/**
 * Klasa reprezentująca centralę Totolotka
 * Odpowiedzialna za przeprowadzanie losowań, zarządzanie pulami nagród,
 * obsługę kolektur i kuponów oraz współpracę z budżetem państwa
 */
public class Centrala {
    // Lista przechowująca całkowite pule środków dla każdego losowania
    private List<Long> pule;
    // Lista przechowująca pule nagród I stopnia (6 trafień) dla każdego losowania
    private List<Long> pule1Stopnia;

    private List<Losowanie> losowania;
    // Lista wszystkich kolektur w systemie
    private List<Kolektura> kolektury;
    // Budżet centrali w groszach
    private long budzet;
    // Referencja do budżetu państwa dla podatków i subwencji
    private BudzetPanstwa bp;
    // Numer następnego losowania do przeprowadzenia
    private int nastLosowanie;
    // Licznik wszystkich wystawionych kuponów
    private List<Kupon> kupony;
    // Łączny zysk centrali w groszach
    private long zysk;
    private int ileKuponow;
    private int poprzedniWygrani1;

    /**
     * Konstruktor centrali Totolotka
     * 
     * @param ileKolektur liczba kolektur do utworzenia
     * @param budzet      początkowy budżet centrali w groszach
     */
    public Centrala( int ileKolektur , long budzet) {
        // Inicjalizacja wszystkich list
        this.pule = new ArrayList<>();
        this.pule1Stopnia = new ArrayList<>();
        this.pule1Stopnia.add(0L);
        this.kupony = new ArrayList<>();
        this.losowania = new ArrayList<>();
        this.kolektury = new ArrayList<>();
        this.budzet = budzet;
        this.zysk = 0;
        this.ileKuponow = 0;
        // Pierwsze losowanie ma numer 1
        this.nastLosowanie = 1;
        // Początkowo brak kuponów

        // Utworzenie określonej liczby kolektur
        for (int j = 0; j < ileKolektur; j++) {
            this.kolektury.add(new Kolektura(this, j));
        }
        for(int i  = 0 ; i < 1000 ; i ++ ){
            this.pule.add(0L);
        }
        // Utworzenie instancji budżetu państwa
        this.bp = new BudzetPanstwa();
    }

    /**
     * Dodaje środki do budżetu centrali
     * 
     * @param p kwota do dodania w groszach (musi być nieujemna)
     * @throws IllegalArgumentException gdy próbuje się odjąć środki
     */
    public void dodajBudzet(long p) {
        if (p < 0) {
            throw new IllegalArgumentException("!!!Proba zabronionego wyciagniecia pieniedzy !!!");
        }
        this.budzet += p;
    }

    /**
     * @return numer następnego losowania
     */
    public int getLosowanie() {
        return this.nastLosowanie;
    }


    /**
     * @return łączną liczbę wystawionych kuponów
     */


    /**
     * @return numer następnego losowania (alias dla getLosowanie)
     */
    public int nastLosowanie() {
        return this.nastLosowanie;
    }

    /**
     * Sprawdza czy dana wartość występuje w tablicy
     * 
     * @param array   tablica do przeszukania
     * @param szukana wartość do znalezienia
     * @return true jeśli wartość została znaleziona
     */
    private Boolean wTablicy(int[] array, int szukana) {

        for (int i = 0; i < array.length; i++) {
            if (array[i] == szukana) {
                return true;
            }
        }
        return false;
    }

    /**
     * Przeprowadza pojedyncze losowanie
     * Generuje wyniki, sprawdza zwycięzców, oblicza pule nagród,
     * stosuje kumulację i przypisuje wygrane do kuponów
     */
    private void przeprowadzLosowanie() {
        // Listy przechowujące zwycięzców każdego stopnia
        List<Kupon> wygrani1 = new ArrayList<>(); // 6 trafień
        List<Kupon> wygrani2 = new ArrayList<>(); // 5 trafień
        List<Kupon> wygrani3 = new ArrayList<>(); // 4 trafienia
        List<Kupon> wygrani4 = new ArrayList<>(); // 3 trafienia

        // Utworzenie nowego losowania z wylosowanymi liczbami
        Losowanie losowanie = new Losowanie(this.nastLosowanie);
        long pula = this.pule.get(this.nastLosowanie); // Początkowa pula (będzie obliczona później
        this.losowania.add(losowanie);
        this.pule1Stopnia.add(0L);

        // Sprawdzenie wszystkich kuponów pod kątem wygranych
        for (int i = 0; i < this.kupony.size(); i++) {
            Kupon kupon = this.kupony.get(i);
            // Sprawdź czy kupon uczestniczy w tym losowaniu
            if (wTablicy(kupon.getLosowania(), this.nastLosowanie )) {
                // Sprawdź wszystkie zakłady w kuponie
                for (int j = 0; j < kupon.getZaklady().size(); j++) {
                    Zaklad zaklad = kupon.getZaklady().get(j);
                    int poprawne = porownajWyniki(losowanie.getWyniki(), zaklad.getTypy());
                    // Przypisz kupon do odpowiedniej kategorii zwycięzców
                    if (poprawne == 3) {
                        wygrani4.add(kupon);
                    } else if (poprawne == 4) {
                        wygrani3.add(kupon);
                    } else if (poprawne == 5) {
                        wygrani2.add(kupon);
                    } else if (poprawne == 6) {
                        wygrani1.add(kupon);
                    }
                    losowanie.dodajZaklad();
                }
            }
        }

        // Oblicz pule nagród
        this.pule1Stopnia.set(this.nastLosowanie , (this.pule.get(this.nastLosowanie ) * 44) / 100);
        long pule2Stopnia = (this.pule.get(this.nastLosowanie )* 8) / 100;


        // Oblicz pulę IV stopnia (24,00 zł za każdą nagrodę)
        long pula4 = wygrani4.size() * 2400;

        // Oblicz pulę III stopnia jako resztę
        long pule3Stopnia = (this.pule.get(this.nastLosowanie) * (100 - 44 - 8)) / 100 - pula4;


        // Sprawdź minimalną pulę I stopnia (2 mln zł = 200_000_000 groszy)
        if (this.pule1Stopnia.get(nastLosowanie -1  ) < 200_000_000L ) {
            this.pule1Stopnia.set(nastLosowanie-1, 200_000_000L);
        }
        if(poprzedniWygrani1 == 0) {

            {
                this.pule1Stopnia.set(nastLosowanie, this.pule1Stopnia.get(nastLosowanie) + this.pule1Stopnia.get(nastLosowanie - 1));
                this.pule.set(nastLosowanie, this.pule.get(nastLosowanie) + this.pule.get(nastLosowanie - 1));
            }
        }



        // Sprawdź czy budżet jest ujemny i pobierz subwencję
        if (this.budzet < 0) {
            this.wystapOSubwencje();
            this.budzet = 0; // Wyzeruj budżet po subwencji
        }
        // Sprawdz kumulacje

        // Oblicz indywidualne nagrody dla zwycięzców
        long nagroda1 = 0;
        long nagroda2 = 0;
        long nagroda3 = 0;
        long nagroda4 = 2400; // Stała nagroda IV stopnia (24,00 zł)

        // Podziel pule między zwycięzców (z zabezpieczeniem przed dzieleniem przez
        // zero)
        if (!wygrani1.isEmpty()) {
            nagroda1 = this.pule1Stopnia.get(this.nastLosowanie - 1) / wygrani1.size();
        }
        if (!wygrani2.isEmpty()) {
            nagroda2 = pule2Stopnia / wygrani2.size();
        }
        if (!wygrani3.isEmpty()) {
            nagroda3 = pule3Stopnia / wygrani3.size();
            // Sprawdź minimalną nagrodę III stopnia (36,00 zł = 3600 groszy)
            if (nagroda3 < 3600)
                nagroda3 = 3600;
        }

        // Zapisz nagrody w obiekcie losowania
        long[] nagrody = { nagroda1, nagroda2, nagroda3, nagroda4 };
        this.losowania.get(this.nastLosowanie - 1).setNagrody(nagrody);

        // Utwórz listę par (zwycięzcy, nagroda) dla łatwiejszego przetwarzania
        List<Map.Entry<List<Kupon>, Long>> wygrane = Arrays.asList(
                Map.entry(wygrani1, nagroda1),
                Map.entry(wygrani2, nagroda2),
                Map.entry(wygrani3, nagroda3),
                Map.entry(wygrani4, nagroda4));

        // Przypisz wygrane do odpowiednich kuponów
        for (var para : wygrane) {
            for (Kupon kupon : para.getKey()) {
                kupon.dodajWygrana(para.getValue());
            }
        }
        poprzedniWygrani1 = wygrani1.size();
        this.nastLosowanie++;

    }

    /**
     * Porównuje wyniki losowania z typowaniem gracza
     * 
     * @param wyniki wylosowane liczby (posortowane)
     * @param typy   liczby wytypowane przez gracza
     * @return liczba trafień (BŁĘDNIE OBLICZONA)
     */
    private int porownajWyniki(int[] wyniki, int[] typy) {
        int ile = 0;
        if (wyniki.length == typy.length && typy.length == 6) {
            for (int i = 0; i < 6; i++) {
                if (wyniki[i] == typy[i])
                    ile++;

            }
            return ile;
        } else {
            throw new IllegalArgumentException("Porownywane typowania  musza miec dlugosc 6");
        }
    }

    /**
     * Przeprowadza n kolejnych losowań
     * 
     * @param n liczba losowań do przeprowadzenia
     */
    public void przeprowadzNLosowania(int n) {
        for (int i = 0; i < n; i++) {
            przeprowadzLosowanie();
        }
    }

    public int ileKuponow(){return this.ileKuponow;}
    /**
     * Dodaje środki do puli określonego losowania
     * 
     * @param ktorej indeks losowania
     * @param ile    kwota do dodania w groszach
     */
    public void dodajDoPuli(int ktorej, long ile) {
        this.pule.set(ktorej, this.pule.get(ktorej) + ile);
    }

    /**
     * Usuwa kupon z systemu (np. po realizacji wygranej)
     * 
     * @param kpn kupon do usunięcia
     */
    public void usunKupon(Kupon kpn) {
        this.kupony.remove(kpn);
    }

    /**
     * Dodaje kupon do systemu
     * 
     * @param k kupon do dodania
     */
    public void dodajKupon(Kupon k) {
        this.ileKuponow++;
        this.kupony.add(k);
    }

    /**
     * Dodaje kwotę do zysku centrali
     * 
     * @param ile kwota zysku w groszach
     */
    public void dodajZysk(long ile) {
        this.zysk += ile;
    }

    /**
     * @return referencję do budżetu państwa
     */
    public BudzetPanstwa getPanstwo() {
        return this.bp;
    }
    public List<Kupon> getKupony() {return this.kupony;}
    /**
     * Występuje o subwencję z budżetu państwa
     * Pobiera kwotę równą ujemnemu budżetowi centrali
     */
    public void wystapOSubwencje() {
        this.bp.udzielSubwencji(-this.budzet);
    }
    public List<Long> getPule(){return this.pule;}
    public List<Long> getPule1Stopnia(){return this.pule1Stopnia;}
    /**
     * Wyświetla informacje o określonym losowaniu
     * 
     * @param i indeks losowania do wyświetlenia
     */
    public void pokazLosowanie(int i) {
        System.out.print(this.losowania.get(i).toString());
    }
    public long getBudzet(){return this.budzet;}
    public List<Kolektura> getKolektury() {return this.kolektury;}
    public List<Losowanie> getLosowania(){return this.losowania;}
    public void wyplacWygrana(long kwota){
        this.budzet -= kwota;
    }

}


import java.util.ArrayList;
import java.util.List;

public abstract class Gracz {
    protected long pieniadze;
    protected List<Kupon> kupony;
    protected String imie;
    protected String nazwisko;
    protected int PESEL;
    protected List<Kolektura> kolektury;

    abstract void kupKupon();

    public Gracz(long p, String i, String n, int ps, List<Kolektura> k) {
        this.kolektury = k;
        this.nazwisko = n;
        this.kupony = new ArrayList<>();
        this.pieniadze = p;
        this.imie = i;
        this.PESEL = ps;
    }

    public void dodajKupon(Kupon k) {
        kupony.add(k);
    }

    public long ilePieniedzy() {
        return this.pieniadze;
    }

    public long zaplac(long ile) {
        this.pieniadze -= ile;
        return ile;
    }

    public void odbierzPieniadze(long ile) {
        if (ile < 0) {
            throw new IllegalArgumentException("Zaszla pomylka przy wyplacaniu wygranej ");
        }
        this.pieniadze += ile;

    }

    protected void wyplacKupon(Kupon k) {
        if (this.kupony.contains(k) == false) {
            throw new IllegalArgumentException("Musisz mieć kupon aby go wypłacić");
        }
        k.getKolektura().wyplacWygrana(this, k);
        k.getKolektura().getCentrala().usunKupon(k);
        k.getKolektura().usunKupon(k);
        this.kupony.remove(k);

    }

    /**
     * Sprawdza wszystkie kupony i realizuje te, które mają zakończone losowania
     * oraz przyniosły jakąś wygrą
     */
    protected void sprawdzKupony() {
        List<Kupon> kuponydoUsuniecia = new ArrayList<>();

        for (Kupon kupon : this.kupony) {
            // Sprawdź czy wszystkie losowania dla tego kuponu zostały przeprowadzone
            if (kupon.koniecLos() == true) {
                // Sprawdź czy kupon ma jakąś wygraną
                if (kupon.getWygrana() > 0) {
                    // Realizuj kupon (wypłać wygraną)
                    wyplacKupon(kupon);
                }
                kuponydoUsuniecia.add(kupon);
            }
        }

        // Usuń zrealizowane kupony
        for (Kupon kupon : kuponydoUsuniecia) {
            this.wyplacKupon(kupon);
        }
    }

    @Override
    public String toString() { // DODANE
        StringBuilder sb = new StringBuilder();
        sb.append("Gracz: ").append(this.nazwisko).append(" ").append(this.imie)
                .append(", PESEL: ").append(this.PESEL)
                .append(", Środki: ").append(this.pieniadze).append(" groszy");

        if (this.kupony.isEmpty()) {
            sb.append(", Brak kuponów");
        } else {
            sb.append(", Kupony: ");
            for (int i = 0; i < this.kupony.size(); i++) {
                sb.append(this.kupony.get(i).toString());
                if (i < this.kupony.size() - 1) {
                    sb.append(", ");
                }
            }
        }

        return sb.toString();
    }
    public List<Kupon> getKupony() {return this.kupony;}

}

import java.util.*;

public class Kolektura {
    private List<Kupon> kupony;
    private Centrala centrala;
    private int numer;

    public Kolektura(Centrala c, int i) {
        this.centrala = c;
        this.numer = i;
        this.kupony = new ArrayList<>();
    }

    public void wyplacWygrana(Gracz g, Kupon k) {
        if(!this.kupony.contains(k)) {
            throw new IllegalArgumentException("Kupon mozna wyplacic jedynie w kolekturze w ktorej zostal zakupiony");
        }
        long wygrana = opodatkujWygrane(k.getWygrana());

        this.centrala.wyplacWygrana(wygrana);
    }

    private long opodatkujWygrane(long wygrana){

            long opodatkowane = ((wygrana)*90)/100;
            this.centrala.getPanstwo().dodajPieniadze(wygrana- opodatkowane);
            return opodatkowane;


    }
    public Centrala getCentrala() {
        return this.centrala;
    }

    public int getNumer() {
        return this.numer;
    }

    public void wydajKupon(List<Zaklad> zaklady, int ileLosowan, Gracz g) {
        long cena = zaklady.size() * ileLosowan * 300L; // 3 zł za zakład w groszach
        if (cena > g.ilePieniedzy()) {
            throw new IllegalArgumentException("Niedostateczne fundusze");
        }
        Kupon kupon = new Kupon(zaklady, ileLosowan, this);

        // To sa informacje dotyczace tego ile pieniedzy jest w puli na kazde z losowan
        // rzeczywiste pieniadze znajduja sie w polach budzet i pieniadze
        g.zaplac(cena);
        long opodatkowane = odprowadzPodatek(cena);
        long budzet = (opodatkowane *51)/100;
        long kwotaNaLosowanie = budzet/ileLosowan;
        this.centrala.dodajZysk(opodatkowane -budzet);
        this.centrala.dodajBudzet(budzet);
        for (int i = 0; i < kupon.getLosowania().length; i++) {
            centrala.dodajDoPuli( kupon.getLosowania()[i] -1, kwotaNaLosowanie);
        }
        g.dodajKupon(kupon);
        this.kupony.add(kupon);
        this.centrala.dodajKupon(kupon);

    }

    public void usunKupon(Kupon kpn) {
        this.kupony.remove(kpn);
    }

    public void wydajKuponChybilTrafil(int ileZakladow, int ileLosowan, Gracz gracz) {

        // Wygeneruj losowe zakłady
        List<Zaklad> zaklady = new ArrayList<>();
        for (int i = 0; i < ileZakladow; i++) {
            int[] losoweLiczby = generujLosoweLiczby();
            zaklady.add(new Zaklad(losoweLiczby));
        }

        // Wydaj kupon
        wydajKupon(zaklady, ileLosowan, gracz);
    }

    /**
     * Generuje losowy zestaw 6 liczb z zakresu 1-49
     * 
     * @return posortowana tablica 6 unikalnych liczb
     */
    private int[] generujLosoweLiczby() {
        Random random = new Random();
        Set<Integer> wylosowane = new HashSet<>();

        while (wylosowane.size() < 6) {
            int liczba = random.nextInt(49) + 1; // 1-49
            wylosowane.add(liczba);
        }

        return wylosowane.stream()
                .mapToInt(Integer::intValue)
                .sorted()
                .toArray();
    }
    private long odprowadzPodatek(long cena ){
        long podatek = (cena*20)/100;
        this.centrala.getPanstwo().dodajPieniadze(podatek);
        return cena-podatek;
    }
}


import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class Kupon {
    private String id;
    private List<Zaklad> zaklady;
    private int ileLosowan;
    private int[] numLosowan;
    private long cena;
    private Kolektura kolektura;
    private long wygrana;

    public Kupon(List<Zaklad> z, int ileL, Kolektura k) {
        this.wygrana = 0;
        cena = 300L * z.size() * ileL;
        int suma = 0;
        this.ileLosowan = ileL;
        this.numLosowan = new int[ileL];
        this.kolektura = k;
        this.zaklady =z;
        String s = "";
        int numerKuponu = this.kolektura.getCentrala().ileKuponow();
        int numerKolektury = this.kolektura.getNumer();
        s += numerKuponu + "-";
        s += numerKolektury + "-";
        while (numerKuponu > 0) {
            suma += numerKuponu % 10;
            numerKuponu /= 10;
        }
        while (numerKolektury > 0) {
            suma += numerKolektury % 10;
            numerKolektury /= 10;
        }
        for (int i = 0; i < 9; i++) {
            int rand = ThreadLocalRandom.current().nextInt(0, 10);
            suma += rand;
            s += rand;
        }
        s += suma%100;
        this.id = s;
        for (int j = 0; j < ileL; j++) {
            this.numLosowan[j] = j   + k.getCentrala().nastLosowanie()   ;
        }
    }

    public long getCena() {
        return this.cena;
    }

    public long getWygrana() {
        return this.wygrana;
    }

    public void dodajWygrana(long w) {
        this.wygrana += w;
    }

    public Kolektura getKolektura() {
        return this.kolektura;
    }

    public List<Zaklad> getZaklady() {
        return this.zaklady;
    }

    public int[] getLosowania() {
        return this.numLosowan;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        // 1. Identyfikator kuponu
        sb.append("KUPON NR ").append(this.id).append("\n");

        // 2. Ponumerowana lista kolejnych zakładów (w osobnych wierszach, wylosowane
        // liczby wyrównane do prawej)
        for (int i = 0; i < this.zaklady.size(); i++) {
            sb.append(i + 1).append(": ");
            int[] typy = this.zaklady.get(i).getTypy();
            for (int j = 0; j < typy.length; j++) {
                if (typy[j] < 10) {
                    sb.append(" "); // Dodatkowa spacja dla liczb jednocyfrowych (wyrównanie do prawej)
                }
                sb.append(typy[j]);
                if (j < typy.length - 1) {
                    sb.append(" ");
                }
            }
            sb.append(" \n"); // Końcowa spacja i nowa linia
        }

        // 3. Liczba losowań
        sb.append("LICZBA LOSOWAŃ: ").append(this.ileLosowan).append("\n");

        // 4. Lista numerów losowań (w jednym wierszu)
        sb.append("NUMERY LOSOWAŃ:\n");
        for (int i = 0; i < this.numLosowan.length; i++) {
            if (i == 0) {
                sb.append(" "); // Początkowa spacja
            }
            sb.append(this.numLosowan[i]);
            if (i < this.numLosowan.length - 1) {
                sb.append(" ");
            }
        }
        sb.append("\n");

        // 5. Cena brutto kuponu
        long zlote = this.cena / 100;
        long grosze = this.cena % 100;
        sb.append("CENA: ").append(zlote).append(" zł ");
        if (grosze < 10) {
            sb.append("0"); // Zero wiodące dla groszy jednocyfrowych
        }
        sb.append(grosze).append(" gr");

        return sb.toString();
    }

    public Boolean koniecLos() {
        int ostatnieLosowanieKuponu = this.numLosowan[ileLosowan - 1];
        int aktualneNastepneLosowanie = this.kolektura.getCentrala().nastLosowanie();

        return (this.numLosowan[ileLosowan - 1] < this.kolektura.getCentrala().nastLosowanie());   }

}


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class KuponTest {
    private Centrala centrala;
    private Kolektura kolektura;
    private List<Zaklad> zaklady;

    @BeforeEach
    void setUp() {
        centrala = new Centrala(1, 1000000L);
        kolektura = centrala.getKolektury().get(0);

        zaklady = new ArrayList<>();
        zaklady.add(new Zaklad(new int[]{1, 2, 3, 4, 5, 6}));
        zaklady.add(new Zaklad(new int[]{7, 8, 9, 10, 11, 12}));
    }

    @Test
    void testTworzenieKuponu() {
        Kupon kupon = new Kupon(zaklady, 1, kolektura);

        assertNotNull(kupon);
        assertEquals(600L, kupon.getCena()); // 2 zakłady * 1 losowanie * 300 groszy
        assertEquals(2, kupon.getZaklady().size());
        assertEquals(1, kupon.getLosowania().length);
    }

    @Test
    void testObliczanieCenyKuponu() {
        // Test dla różnych kombinacji zakładów i losowań
        Kupon kupon1 = new Kupon(zaklady, 1, kolektura); // 2 zakłady, 1 losowanie
        assertEquals(600L, kupon1.getCena());

        Kupon kupon2 = new Kupon(zaklady, 5, kolektura); // 2 zakłady, 5 losowań
        assertEquals(3000L, kupon2.getCena());

        List<Zaklad> pojedynczyZaklad = Arrays.asList(new Zaklad(new int[]{1, 2, 3, 4, 5, 6}));
        Kupon kupon3 = new Kupon(pojedynczyZaklad, 1, kolektura); // 1 zakład, 1 losowanie
        assertEquals(300L, kupon3.getCena());
    }

    @Test
    void testGenerowanieIdentyfikatoraKuponu() {
        Kupon kupon1 = new Kupon(zaklady, 1, kolektura);
        Kupon kupon2 = new Kupon(zaklady, 1, kolektura);

        assertNotNull(kupon1.toString());
        assertNotNull(kupon2.toString());
        // Identyfikatory powinny być różne
        assertNotEquals(kupon1.toString(), kupon2.toString());
    }

    @Test
    void testDodawanieWygranej() {
        Kupon kupon = new Kupon(zaklady, 1, kolektura);

        assertEquals(0L, kupon.getWygrana());

        kupon.dodajWygrana(2400L);
        assertEquals(2400L, kupon.getWygrana());

        kupon.dodajWygrana(1200L);
        assertEquals(3600L, kupon.getWygrana());
    }

    @Test
    void testKoniecLosowania() {
        Kupon kupon = new Kupon(zaklady, 2, kolektura);

        // Na początku losowania nie są zakończone
        assertFalse(kupon.koniecLos());

        // Po przeprowadzeniu losowań
        centrala.przeprowadzNLosowania(3);
        assertTrue(kupon.koniecLos());
    }
}


import java.util.*;

public class Losowanie {
    private int id;
    private long[] nagrody;
    private int[] wynik;
    private List<Kupon> zwyciezcy;
    private int ileZakladow;
    public Losowanie(int numerLosowania) {
        this.nagrody = new long[4];
        this.ileZakladow = 0;
        this.id = numerLosowania;
        this.zwyciezcy = new ArrayList<>();
        this.wynik = new int[6];
        Random random = new Random();
        Set<Integer> wylosowane = new HashSet<>();

        while (wylosowane.size() < 6) {
            int liczba = random.nextInt(49) + 1;
            wylosowane.add(liczba);
        }

        this.wynik = wylosowane.stream()
                .mapToInt(Integer::intValue)
                .sorted()
                .toArray();
    }

    public void dodajZwyciezce(Kupon kupon) {
        this.zwyciezcy.add(kupon);
    }

    public int[] getWyniki() {
        return this.wynik;
    }
    public int getNumer(){return this.id;}
    public void dodajZaklad(){
        this.ileZakladow++;
    }
    public int ileZakladow(){return this.ileZakladow;}
    public void setNagrody(long[] w) {
        this.nagrody = w;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        // Numer losowania
        sb.append("Losowanie nr ").append(this.id).append("\n");

        // Wyniki - liczby wyrównane do prawej z dodatkową spacją dla liczb
        // jednocyfrowych
        sb.append("Wyniki: ");
        for (int i = 0; i < this.wynik.length; i++) {
            if (this.wynik[i] < 10) {
                sb.append(" "); // Dodatkowa spacja dla liczb jednocyfrowych
            }
            sb.append(this.wynik[i]);
            if (i < this.wynik.length - 1) {
                sb.append(" ");
            }
        }
        sb.append(" "); // Końcowa spacja zgodnie ze specyfikacją

        return sb.toString();
    }

}


import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

public class Losowy extends Gracz {

    public Losowy(String i, String n, int ps, List<Kolektura> dostepneKolektury, List<Kolektura> k) {
        // Losowa kwota mniej niż milion zł (100_000_000 groszy)
        super(ThreadLocalRandom.current().nextLong(1, 100_000_000), i, n, ps, k);
        this.kolektury = dostepneKolektury;
    }

    /**
     * Implementacja abstrakcyjnej metody z klasy Gracz
     * Gracz losowy nie używa blankietów - kupuje tylko kupony chybił-trafił
     */

    void wypelnijBlankiet() {
        throw new UnsupportedOperationException("Gracz losowy nie używa blankietów");
    }

    /**
     * Kupuje losową liczbę kuponów chybił-trafił (od 1 do 100)
     * w losowo wybranej kolekturze
     */
    @Override
    void kupKupon() {
        if (this.kolektury.isEmpty()) {
            throw new UnsupportedOperationException("Brak dostepnych kolektur");
        }

        // Losowa liczba kuponów do kupienia (1-100)
        int liczbaKuponow = ThreadLocalRandom.current().nextInt(1, 101);

        for (int i = 0; i < liczbaKuponow; i++) {
            // Sprawdź czy gracz ma jeszcze środki na minimalny kupon (3 zł = 300 groszy)
            if (this.pieniadze < 300L) {
                break; // Brak środków na kolejne kupony
            }

            try {
                // Losowo wybierz kolekturę
                Kolektura wybranaKolektura = kolektury.get(
                        ThreadLocalRandom.current().nextInt(kolektury.size()));

                // Losowa liczba zakładów (1-8, zgodnie z ograniczeniami kuponu)
                int liczbaZakladow = ThreadLocalRandom.current().nextInt(1, 9);

                // Losowa liczba losowań (1-10, zgodnie z ograniczeniami kuponu)
                int liczbaLosowan = ThreadLocalRandom.current().nextInt(1, 11);

                /*
                 * Zarowno gracz jak i kupon tj kolektura sprawdzaja czygracza stac na dany
                 * kupon co lepiej odwzorowywujefunkcjonowanie swiata rzeczywistego
                 */
                long cenaKuponu = liczbaZakladow * liczbaLosowan * 300L;
                if (cenaKuponu <= this.pieniadze) {
                    wybranaKolektura.wydajKuponChybilTrafil(liczbaZakladow, liczbaLosowan, this);
                } else {
                    break; // Brak środków na ten kupon
                }

            } catch (IllegalArgumentException e) {
                // Jeśli nie ma środków lub inny błąd, przerwij kupowanie
                break;
            }
        }
    }

    /**
     * Ustawia nową listę dostępnych kolektur na wypadek gdyby losowy losowo chcial zmiany
     */
    public void setKolektury(List<Kolektura> kolektury) {
        this.kolektury = kolektury;
    }
}


import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Random;
import java.util.Set;

public class Main {
    // Stałe konfiguracyjne dla demonstracji
    private static final int LICZBA_KOLEKTUR = 10;
    private static final int GRACZE_KAZDEGO_TYPU = 20; // Zmniejszone dla demonstracji
    private static final int LICZBA_LOSOWAN = 5; // Zmniejszone dla demonstracji

    public static void main(String[] args) {
        System.out.println("=== DEMONSTRACJA SYSTEMU TOTOLOTEK ===\n");

        // 1. Inicjalizacja systemu
        Centrala centrala = new Centrala(LICZBA_KOLEKTUR, 10_000_000L);
        List<Gracz> gracze = createAllPlayers(centrala);

        printSystemStatus("STAN POCZĄTKOWY", centrala, gracze.size());

        // 2. Symulacja losowań
        for (int losowanie = 1; losowanie <= LICZBA_LOSOWAN; losowanie++) {
            System.out.println("\n--- LOSOWANIE " + losowanie + " ---");

            // Kupowanie kuponów przez graczy
            int kupioneKupony = buyTickets(gracze);
            System.out.println("Kupiono kuponów: " + kupioneKupony);

            // Przeprowadzenie losowania
            centrala.przeprowadzNLosowania(1);
            centrala.pokazLosowanie(losowanie - 1);

            // Wypłata wygranych
            int wyplaconeWygrane = processWinnings(gracze);
            System.out.println("Wypłacono wygranych: " + wyplaconeWygrane);

            // Status po losowaniu
            long pula = centrala.getPule().get(losowanie - 1);
            System.out.println("Pula tego losowania: " + formatMoney(pula));
        }

        // 3. Podsumowanie końcowe
        printFinalSummary(centrala, gracze);
    }

    private static List<Gracz> createAllPlayers(Centrala centrala) {
        List<Gracz> gracze = new ArrayList<>();
        List<Kolektura> kolektury = centrala.getKolektury();

        // Tworzenie graczy Minimalistów
        for (int i = 0; i < GRACZE_KAZDEGO_TYPU; i++) {
            Kolektura ulubiona = kolektury.get(i % LICZBA_KOLEKTUR);
            gracze.add(new Minimalista("Min" + i, "Nazwisko" + i, 10000000 + i,
                    ulubiona, kolektury));
        }

        // Tworzenie graczy Losowych
        for (int i = 0; i < GRACZE_KAZDEGO_TYPU; i++) {
            gracze.add(new Losowy("Los" + i, "Nazwisko" + i, 20000000 + i,
                    kolektury, kolektury));
        }

        // Tworzenie graczy Stałoliczbowych
        for (int i = 0; i < GRACZE_KAZDEGO_TYPU; i++) {
            int[] ulubioneLiczby = generateFavoriteNumbers(i);
            Kolektura[] ulubione = { kolektury.get(i % LICZBA_KOLEKTUR),
                    kolektury.get((i + 1) % LICZBA_KOLEKTUR) };
            gracze.add(new Staloliczbowy(50_000_000L, "Stal" + i, "Nazwisko" + i,
                    30000000 + i, ulubioneLiczby, kolektury, ulubione));
        }

        // Tworzenie graczy Stałoblankietowych
        for (int i = 0; i < GRACZE_KAZDEGO_TYPU; i++) {
            List<Set<Integer>> typy = generateBlankietTypes(i);
            Kolektura[] ulubione = { kolektury.get(i % LICZBA_KOLEKTUR),
                    kolektury.get((i + 1) % LICZBA_KOLEKTUR),
                    kolektury.get((i + 2) % LICZBA_KOLEKTUR) };

            Blankiet blankiet = new Blankiet(kolektury.get(i % LICZBA_KOLEKTUR), 3, typy);
            gracze.add(new StaloBlankietowy(100_000_000L, "Blank" + i, "Nazwisko" + i,
                    40000000 + i, kolektury, blankiet, 2, ulubione));
        }

        System.out.println("Utworzono " + gracze.size() + " graczy:");
        System.out.println("- Minimaliści: " + GRACZE_KAZDEGO_TYPU);
        System.out.println("- Losowi: " + GRACZE_KAZDEGO_TYPU);
        System.out.println("- Stałoliczbowi: " + GRACZE_KAZDEGO_TYPU);
        System.out.println("- Stałoblankietowi: " + GRACZE_KAZDEGO_TYPU);

        return gracze;
    }

    private static int[] generateFavoriteNumbers(int seed) {
        Random rand = new Random(seed);
        Set<Integer> numbers = new HashSet<>();
        while (numbers.size() < 6) {
            numbers.add(rand.nextInt(49) + 1);
        }
        return numbers.stream().mapToInt(Integer::intValue).sorted().toArray();
    }

    private static List<Set<Integer>> generateBlankietTypes(int seed) {
        List<Set<Integer>> types = new ArrayList<>();
        for (int j = 0; j < 3; j++) {
            Set<Integer> type = new HashSet<>();
            Random rand = new Random(seed * 10 + j);
            while (type.size() < 6) {
                type.add(rand.nextInt(49) + 1);
            }
            types.add(type);
        }
        return types;
    }

    private static int buyTickets(List<Gracz> gracze) {
        int kupione = 0;
        for (Gracz gracz : gracze) {
            int kuponowPrzed = gracz.getKupony().size();
            try {
                gracz.kupKupon();
                int kuponowPo = gracz.getKupony().size();
                if (kuponowPo > kuponowPrzed) {
                    kupione++;
                }
            } catch (Exception e) {
                // Gracz nie mógł kupić kuponu (brak środków itp.)
            }
        }
        return kupione;
    }

    private static int processWinnings(List<Gracz> gracze) {
        int wyplacone = 0;
        for (Gracz gracz : gracze) {
            List<Kupon> doWyplaty = new ArrayList<>();

            for (Kupon kupon : gracz.getKupony()) {
                if (kupon.koniecLos() && kupon.getWygrana() > 0) {
                    doWyplaty.add(kupon);
                }
            }

            for (Kupon kupon : doWyplaty) {
                try {
                    gracz.wyplacKupon(kupon);
                    wyplacone++;
                } catch (Exception e) {
                    // Błąd wypłaty
                }
            }
        }
        return wyplacone;
    }

    private static void printSystemStatus(String etap, Centrala centrala, int liczbaGraczy) {
        System.out.println("\n=== " + etap + " ===");
        System.out.println("Budżet centrali: " + formatMoney(centrala.getBudzet()));
        System.out.println("Liczba graczy: " + liczbaGraczy);
        System.out.println("Liczba kolektur: " + centrala.getKolektury().size());
        System.out.println("Kupony w systemie: " + centrala.ileKuponow());
    }

    private static void printFinalSummary(Centrala centrala, List<Gracz> gracze) {
        System.out.println("\n=== PODSUMOWANIE KOŃCOWE ===");
        System.out.println("Przeprowadzono losowań: " + centrala.getLosowania().size());
        System.out.println("Wystawiono kuponów: " + centrala.ileKuponow());
        System.out.println("Stan końcowy centrali: " + formatMoney(centrala.getBudzet()));
        System.out.println("Wpływy do budżetu państwa: " + centrala.getPanstwo().toString());

        // Statystyki graczy
        long sumaGraczy = gracze.stream().mapToLong(g -> g.ilePieniedzy()).sum();
        int aktywnychKuponow = gracze.stream().mapToInt(g -> g.getKupony().size()).sum();

        System.out.println("\nSTATYSTYKI GRACZY:");
        System.out.println("Łączne środki graczy: " + formatMoney(sumaGraczy));
        System.out.println("Aktywnych kuponów: " + aktywnychKuponow);

        System.out.println("\n=== KONIEC DEMONSTRACJI ===");
    }

    private static String formatMoney(long grosze) {
        long zlote = grosze / 100;
        long reszta = grosze % 100;
        return zlote + " zł " + String.format("%02d", reszta) + " gr";
    }
}


import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

public class Minimalista extends Gracz {
    private Kolektura k;

    public Minimalista(String i, String n, int ps, Kolektura kl, List<Kolektura> k) {
        super(ThreadLocalRandom.current().nextLong(1, 1_000_000), i, n, ps, k);
        this.k = kl;
        this.kupony = new ArrayList<>(); // Inicjalizacja listy kuponów
    }

    void wypelnijBlankiet() {
        // Minimalista nie wypełnia blankietów - używa tylko chybił-trafił
        // Ta metoda może pozostać pusta lub rzucać wyjątek
        throw new UnsupportedOperationException("Minimalista nie używa blankietów");
    }

    /**
     * Kupuje kupon zgodnie ze specyfikacją Minimalisty:
     * - jeden zakład na chybił-trafił
     * - tylko na jedno najbliższe losowanie
     * - zawsze w swojej ulubionej kolekturze
     */
    @Override
    public void kupKupon() {
        try {
            this.k.wydajKuponChybilTrafil(1, 1, this);

        } catch (IllegalArgumentException e) {
            // Jeśli nie ma środków, po prostu nie kupuje kuponu
            // Zgodnie ze specyfikacją gracz nie może kupić kuponu bez wystarczających
            // środków
        }
    }

    /**
     * @return ulubioną kolekturę Minimalisty
     */
    public Kolektura getUlubionaKolektura() {
        return this.k;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Minimalista: ").append(this.imie)
                .append(", PESEL: ").append(this.PESEL)
                .append(", Środki: ").append(this.pieniadze).append(" groszy")
                .append(", Ulubiona kolektura: ").append(this.k.getNumer());

        if (this.kupony.isEmpty()) {
            sb.append(", Brak kuponów");
        } else {
            sb.append(", Kupony: ");
            for (int i = 0; i < this.kupony.size(); i++) {
                sb.append(this.kupony.get(i).toString());
                if (i < this.kupony.size() - 1) {
                    sb.append(", ");
                }
            }
        }
        return sb.toString();
    }

}


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class NagrodyTest {
    private Centrala centrala;
    private Kolektura kolektura;
    private Gracz gracz;

    @BeforeEach
    void setUp() {
        centrala = new Centrala(1, 10000000L);
        kolektura = centrala.getKolektury().get(0);
        gracz = new Minimalista("Jan", "Kowalski", 12345678, kolektura, centrala.getKolektury());
        gracz.odbierzPieniadze(100000L); // Dodaj środki graczowi
    }

    @Test
    void testObliczaniePuliNagrod() {
        // Sprzedaj kilka kuponów
        kolektura.wydajKuponChybilTrafil(1, 1, gracz);
        kolektura.wydajKuponChybilTrafil(1, 1, gracz);
        kolektura.wydajKuponChybilTrafil(1, 1, gracz);

        // Sprawdź czy pula została odpowiednio obliczona
        long oczekiwanaPula = (3 * 300 * 80  / 100 * 51 / 100); // 3 kupony * cena * po podatku * 51% na nagrody podloga
        assertEquals(oczekiwanaPula -1 , centrala.getPule().get(0));// -1 bo podloga z dzielenia
    }

    @Test
    void testMinimalnaPulaIPierwszegoStopnia() {
        // Nawet bez sprzedanych kuponów, pula I stopnia powinna wynosić minimum 2 mln zł
        centrala.przeprowadzNLosowania(1);

        assertTrue(centrala.getPule1Stopnia().get(0) >= 200000000L); // 2 mln zł = 200 mln groszy
    }

    @Test
    void testStałaNagrodaIVStopnia() {
        // Nagroda IV stopnia (3 trafienia) zawsze wynosi 24,00 zł = 2400 groszy
        // Ten test sprawdza czy stała jest poprawnie zdefiniowana w kodzie
        long oczekiwanaNagrodaIV = 2400L;
        assertEquals(2400L, oczekiwanaNagrodaIV);
    }

    @Test
    void testMinimalnaNagrodaIIIStopnia() {
        // Nagroda III stopnia nie może być niższa niż 15 * 2,40 zł = 36,00 zł = 3600 groszy
        long minimalnaNagrodaIII = 3600L;
        assertTrue(minimalnaNagrodaIII >= 3600L);
    }
}


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;

public class SprzedazKuponowTest {
    private Centrala centrala;
    private Kolektura kolektura;
    private Gracz gracz;

    @BeforeEach
    void setUp() {
        centrala = new Centrala(1, 1000000L);
        kolektura = centrala.getKolektury().get(0);
        gracz = new Minimalista("Jan", "Kowalski", 12345678, kolektura, centrala.getKolektury());
    }


    @Test
    void testSprzedazKuponuBezWystarczającychŚrodków() {
        // Upewnij się, że gracz ma dokładnie 200 groszy (mniej niż koszt kuponu)
        long aktualneSrodki = gracz.ilePieniedzy();
        if (aktualneSrodki >= 200L) {
            gracz.zaplac(aktualneSrodki - 200L); // Zostaw tylko 200 groszy
        } else {
            gracz.odbierzPieniadze(200L - aktualneSrodki); // Dodaj do 200 groszy
        }

        // Sprawdź, że gracz ma mniej niż koszt kuponu (300 groszy)
        assertTrue(gracz.ilePieniedzy() < 300L);

        // Test powinien rzucić wyjątek z powodu niewystarczających środków
        assertThrows(IllegalArgumentException.class, () -> {
            kolektura.wydajKuponChybilTrafil(1, 1, gracz);
        });

        // Sprawdź, że środki gracza nie zmieniły się (transakcja nie doszła do skutku)
        assertEquals(200L, gracz.ilePieniedzy());
    }


    @Test
    void testOdprowadzaniePodatku() {
        gracz.odbierzPieniadze(1000L);
        long początkowePodatki = centrala.getPanstwo().getPodatki();

        kolektura.wydajKuponChybilTrafil(1, 1, gracz);

        // Podatek to 20% z ceny brutto (0,60 zł z 3,00 zł)
        long oczekiwanyPodatek = 300L * 20 / 100; // 60 groszy
        assertEquals(początkowePodatki + oczekiwanyPodatek, centrala.getPanstwo().getPodatki());
    }

    @Test
    void testDodawanieKuponuDoSystemu() {
        gracz.odbierzPieniadze(1000L);
        int początkowaLiczbaKuponow = centrala.ileKuponow();

        kolektura.wydajKuponChybilTrafil(1, 1, gracz);

        assertEquals(początkowaLiczbaKuponow + 1, centrala.ileKuponow());
        assertEquals(1, gracz.getKupony().size());
    }
}


import java.util.*;

public class StaloBlankietowy extends Gracz {
    private Blankiet staloBlankiet;
    private int coIleLosowania;
    private int licznikLosowania;
    private Kolektura[] mojeKolektury;
    private int aktualnaKolekturaIndex;

    public StaloBlankietowy(long p, String i, String n, int ps, List<Kolektura> k,
            Blankiet bl, int coIle, Kolektura[] favKol) {
        super(p, i, n, ps, k);

        // Walidacja parametrów
        if (bl == null) {
            throw new IllegalArgumentException("Stały blankiet nie może być null");
        }
        if (coIle <= 0) {
            throw new IllegalArgumentException("Częstotliwość kupowania musi być większa od 0");
        }
        if (favKol == null || favKol.length == 0) {
            throw new IllegalArgumentException("Gracz musi mieć przynajmniej jedną ulubioną kolekturę");
        }

        this.staloBlankiet = bl;
        this.coIleLosowania = coIle;
        this.licznikLosowania = 0;
        this.mojeKolektury = favKol;
        this.aktualnaKolekturaIndex = 0;
    }

    /**
     * Implementacja abstrakcyjnej metody z klasy Gracz
     * Gracz stałoblankietowy ma swój blankiet i nie wypełnia nowego
     */

    void wypelnijBlankiet() {
        // Gracz stałoblankietowy ma już swój stały blankiet
        throw new UnsupportedOperationException(
                "Gracz stałoblankietowy nie wypełnia nowego blankietu - ma swój stały blankiet");
    }

    /**
     * Kupuje kupon zgodnie ze specyfikacją Stałoblankietowego:
     * - ma swój stały blankiet
     * - kupuje kupon co pewną stałą liczbę losowań
     * - korzysta z ulubionych kolektur na zmianę
     */
    @Override
    void kupKupon() {
        // Sprawdź czy nadszedł czas na kupno kuponu (co określoną liczbę losowań)
        if (this.licznikLosowania % this.coIleLosowania != 0) {
            return; // Nie czas na kupowanie kuponu
        }

        try {
            // Wybierz kolekturę z rotacją
            Kolektura wybranaKolektura = this.mojeKolektury[this.aktualnaKolekturaIndex];
            this.aktualnaKolekturaIndex = (this.aktualnaKolekturaIndex + 1) % this.mojeKolektury.length;

            // Użyj stałego blankietu do wydania kuponu
            this.staloBlankiet.wydajBlankiet(this);
            this.licznikLosowania++;
        } catch (IllegalArgumentException e) {
            // Jeśli nie ma środków lub inny błąd, po prostu nie kupuje kuponu
        }
    }

    /**
     * Ustawia nowy stały blankiet
     * Bo gracz staloblankietowy podobnie jak my wszyscy moze sie zmienic, ale tylko
     * troche
     */
    public void setStaloBlankiet(Blankiet nowyBlankiet) {
        if (nowyBlankiet == null) {
            throw new IllegalArgumentException("Blankiet nie może być null");
        }
        this.staloBlankiet = nowyBlankiet;
    }

    /**
     * Ustawia nową częstotliwość kupowania kuponów
     */
    public void setCoIleLosowania(int nowaWartosc) {
        if (nowaWartosc <= 0) {
            throw new IllegalArgumentException("Częstotliwość musi być większa od 0");
        }
        this.coIleLosowania = nowaWartosc;
    }

}


import java.util.*;

public class Staloliczbowy extends Gracz {
    private int[] mojeLiczby;
    private Kolektura[] mojeKolektury;
    private int kotraKolektura;

    public Staloliczbowy(long p, String i, String n, int ps, int[] favLicz, List<Kolektura> k, Kolektura[] favKol) {
        super(p, i, n, ps, k);

        // Walidacja ulubionych liczb
        if (favLicz.length != 6) {
            throw new IllegalArgumentException("Gracz stałoliczbowy musi mieć dokładnie 6 ulubionych liczb");
        }

        // Sprawdź czy liczby są w zakresie 1-49 i są unikalne
        Set<Integer> sprawdzUnikalne = new HashSet<>();
        for (int liczba : favLicz) {
            if (liczba < 1 || liczba > 49) {
                throw new IllegalArgumentException("Liczby muszą być w zakresie 1-49");
            }
            if (!sprawdzUnikalne.add(liczba)) {
                throw new IllegalArgumentException("Liczby muszą być rozne");
            }
        }

        this.mojeLiczby = Arrays.copyOf(favLicz, 6);
        Arrays.sort(this.mojeLiczby); // Posortuj liczby
        this.mojeKolektury = favKol;
        this.kotraKolektura = 0;
    }

    /**
     * Implementacja abstrakcyjnej metody z klasy Gracz
     * Wypełnia blankiet swoimi ulubionymi liczbami
     */
    void wypelnijBlankiet() {
        // Sprawdź czy gracz ma jakiekolwiek kupony
        if (!this.kupony.isEmpty()) {
            Kupon ostatniKupon = this.kupony.get(this.kupony.size() - 1);
            int[] losowania = ostatniKupon.getLosowania();
            int ostatnieLosowanie = losowania[losowania.length - 1];

            // Jeśli poprzedni kupon jeszcze aktywny - nie może kupić nowego
            if (ostatnieLosowanie >= this.kolektury.get(0).getCentrala().nastLosowanie()) {
                return; // Poprzedni kupon jeszcze aktywny
            }
        }

        // Gracz może kupić nowy kupon - wypełnij blankiet swoimi ulubionymi liczbami
        Set<Integer> ulubioneLiczby = new HashSet<>();
        for (int liczba : this.mojeLiczby) {
            ulubioneLiczby.add(liczba);
        }
        List<Set<Integer>> typy = new ArrayList<>();
        typy.add(ulubioneLiczby);

        try {
            Blankiet b = new Blankiet(this.mojeKolektury[this.kotraKolektura], 10, typy);
            b.wydajBlankiet(this);
            this.kotraKolektura = (this.kotraKolektura + 1) % mojeKolektury.length;
        } catch (IllegalArgumentException e) {
            // Jeśli gracz nie ma pieniędzy, zwyczajnie nie kupi kuponu
        }
    }

    @Override
    public void kupKupon() {
        wypelnijBlankiet();
    }

}


import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import static org.junit.jupiter.api.Assertions.*;
import java.util.*;

public class WykrywanieBledowTest {
    private Centrala centrala;
    private Kolektura kolektura;

    @BeforeEach
    void setUp() {
        centrala = new Centrala(1, 1000000L);
        kolektura = centrala.getKolektury().get(0);
    }

    @Test
    void testTworzenieZakladuZDuplikatami() {
        int[] typyZDuplikatami = {1, 1, 2, 3, 4, 5}; // Duplikat liczby 1

        // W obecnej implementacji Zaklad nie sprawdza duplikatów,
        // ale powinien - to jest błąd do wykrycia
        Zaklad zaklad = new Zaklad(typyZDuplikatami);

        // Test sprawdza czy system poprawnie obsługuje duplikaty
        int[] wynik = zaklad.getTypy();
        Set<Integer> unikalne = new HashSet<>();
        for (int liczba : wynik) {
            unikalne.add(liczba);
        }

        // Jeśli są duplikaty, zbiór będzie mniejszy niż tablica
        assertTrue(unikalne.size() <= wynik.length);
    }

    @Test
    void testNiepoprawneDaneWKonstruktorach() {
        // Test dla Zaklad z null
        assertThrows(Exception.class, () -> {
            new Zaklad(null);
        });

        // Test dla pustej tablicy
        assertThrows(IllegalArgumentException.class, () -> {
            new Zaklad(new int[]{});
        });
    }

    @Test
    void testGraniceZakresowLiczb() {
        // Test granicznych wartości
        int[] typy1 = {1, 2, 3, 4, 5, 6}; // Minimalne wartości
        assertDoesNotThrow(() -> new Zaklad(typy1));

        int[] typy2 = {44, 45, 46, 47, 48, 49}; // Maksymalne wartości
        assertDoesNotThrow(() -> new Zaklad(typy2));

        int[] typy3 = {0, 1, 2, 3, 4, 5}; // Poniżej minimum
        assertThrows(IllegalArgumentException.class, () -> new Zaklad(typy3));

        int[] typy4 = {45, 46, 47, 48, 49, 50}; // Powyżej maksimum
        assertThrows(IllegalArgumentException.class, () -> new Zaklad(typy4));
    }
}



import java.util.Arrays;

public class Zaklad {
    private int[] typy;
    boolean anuluj;

    public Zaklad(int[] t, boolean a) {
        this.typy = new int[6];
        if (t.length != 6) {
            anuluj = true;
            throw new IllegalArgumentException("Kazdy Zaklad obejmuje wytypowanie 6 liczb od 1 do 49");
        }
        for (int i = 0; i < 6; i++) {
            if (0 < t[i] && t[i] < 50) {
                this.typy[i] = t[i];
            } else
                throw new IllegalArgumentException("Kazdy Zaklad obejmuje wytypowanie 6 liczb od 1 do 49");
        }
        Arrays.sort(this.typy);
        this.anuluj = a;
    }

    public Zaklad(int[] t) {
        this(t, false);
    }

    public int[] getTypy() {
        return this.typy;
    }


    @Override
    public String toString() {
        String s = "";
        for (int p = 0; p < 10; p++) {
            for (int q = 0; q < 5; q++) {
                int l = p * 10 + q;
                int i = 0;
                s += "[ ";
                if (l < 10) {
                    s += " ";
                }
                if (l != this.typy[i]) {
                    s += l + " ";
                } else {
                    s += "-- ";
                    i++;
                }
                s += " ]  ";
            }
            s += '\n';

        }
        if (this.anuluj == false)
            s += "\n[    ]  anuluj\n";
        else
            s += "\n[ -- ] anuluj\n";
        return s;
    }
}


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class ZakladTest {

    @Test
    void testTworzeniePoprawnegaZakladu() {
        int[] typy = {1, 15, 23, 31, 42, 49};
        Zaklad zaklad = new Zaklad(typy);

        assertNotNull(zaklad);
        assertArrayEquals(new int[]{1, 15, 23, 31, 42, 49}, zaklad.getTypy());
    }

    @Test
    void testSortowanieTypów() {
        int[] typy = {49, 1, 31, 15, 42, 23}; // Nieposortowane
        Zaklad zaklad = new Zaklad(typy);

        assertArrayEquals(new int[]{1, 15, 23, 31, 42, 49}, zaklad.getTypy());
    }

    @Test
    void testZakladZNiepoprawnąLiczbąTypów() {
        int[] typy = {1, 2, 3, 4, 5}; // Tylko 5 liczb

        assertThrows(IllegalArgumentException.class, () -> {
            new Zaklad(typy);
        });
    }

    @Test
    void testZakladZLiczbąPozaZakresem() {
        int[] typy = {1, 2, 3, 4, 5, 50}; // 50 jest poza zakresem

        assertThrows(IllegalArgumentException.class, () -> {
            new Zaklad(typy);
        });

        int[] typy2 = {0, 1, 2, 3, 4, 5}; // 0 jest poza zakresem

        assertThrows(IllegalArgumentException.class, () -> {
            new Zaklad(typy2);
        });
    }

    @Test
    void testZakladZAnulowaniem() {
        int[] typy = {1, 2, 3, 4, 5, 6};
        Zaklad zaklad = new Zaklad(typy, true);

        assertNotNull(zaklad);
        assertTrue(zaklad.anuluj);
    }
}


